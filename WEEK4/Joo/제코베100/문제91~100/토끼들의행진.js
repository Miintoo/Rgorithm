const 돌의내구도 = [1, 2, 1, 4, 5, 2];
const 점프력 = [2, 1, 3, 1];

// 토끼1 => 2칸씩
/*
  돌들[2-1] === 0 이면
    return fail
  돌들[2-1] > 0 이면
    돌들[2-1] -1
다음 돌 진행
  



인덱스를 구하는 관건
어떻게 끝났을까?

길이 = 4
점프력 = 2
밟는인덱스 = 1, 3 , 
- length-1 보다 같거나 작을 때만 
- if( length -1 >= 점프력 )

for문을 +2씩하면?
*/

function solution() {
  const result = Array(점프력.length).fill("pass");

  for (let i in 점프력) {
    for (let j = 점프력[i] - 1; j < 돌의내구도.length; j = j + 점프력[i]) {
      if (돌의내구도[j] === 0) {
        result[i] = "fail";
      } else {
        돌의내구도[j] = 돌의내구도[j] - 1;
      }
    }
  }

  return result;
}

console.log(solution());

// 1. 이 문제를 보고 어떻게 이 솔루션을 떠올렸지?
// 점프력의 배수만큼 돌들을 지나가면서 내구도를 -1씩하면 된다.
// 돌들의 인덱스가 0부터 시작하므로 지나가는 인덱스를 구하는 것이 관건
// 점프력이 2이라면 1번째 인덱스 , 3번째 인덱스를 지나간다.
// 그래서 for문을 돌 때 +1씩 증가하는 것이 아니라 점프력씩 증가하면 된다.
// 시작인덱스는 1번부터 시작하도록 점프력 - 1
// 돌의 내구력이 0이면 실패, 0보다 크면 내구도만 깍음

// result를 표기하는 것에서 막힘
// pass로 깔린 배열을 만들고 fail 되었을 때만 해당 인덱스에 fail을 넣는 방식으로 진행

// 2. 이것보다 더 좋은 방법은 없을까?
/*
for(let i=0; i<점프력.length; i++) {
    let p = 0;
    while (p < 돌의내구도.length-1){
      p += 점프력[i];
      돌의내구도[p-1] -= 1;

      if (돌의내구도[p-1] < 0){
        answe돌의내구도[i] = "fail";
      }
    }
*/

// 점프력 변수를 추가해서 점프력을 더하고 인덱스는 점프력-1
// 비슷비슷하네...?