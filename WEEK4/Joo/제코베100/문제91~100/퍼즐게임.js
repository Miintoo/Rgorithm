// 퍼즐을 빼면 0으로 만들어줘야함

// 조작
/*
1 => [줄][0번째줄] => 줄 중에 0이 아닌 첫번째
1 => [줄][0번째줄] => 줄 중에 0만 있다면 점수만 다운


*/
// 점수 추가 빼기
/*
다 구하고 나서 점수계산하면 되잖아?


  // list의 0번째 인덱스부터 돌다가 0보다 큰 수가 나오면 그 수를 board에 푸쉬
  // 퍼즐판[해당인덱스][1-1] = 0
  // 큰수가 없다면? 점수를 빼자
  //

*/

const 퍼즐판 = [
  [0, 0, 0, 0],
  [0, 1, 0, 3],
  [2, 5, 0, 1],
  [2, 4, 4, 1],
  [5, 1, 1, 1],
];
const 조작 = [1, 1, 1, 1, 3, 3, 3];
const stack = [];
function solution(퍼즐판, 조작) {
  let score = 0;

  while (조작.length !== 0) {
    score += getBoard(퍼즐판, 조작.shift());
    // console.log(퍼즐판, score, board);
  }

  // console.log("last", 퍼즐판);

  const v = stack;
  let p = 0;
  let isSame = false;
  let temp = v[0]; //일시적 sum값
  let prev = v[0]; // 이전숫자
  for (let i = 1; i < v.length; i++) {
    if (v[i] === prev && !isSame) {
      temp += v[i];
      prev = v[i];
      isSame = true;
    } else {
      if (isSame) {
        p += temp;
      }
      temp = v[i];
      prev = v[i];
      isSame = false;
    }
    console.log({ i: v[i], p, temp, prev, isSame });
  }
  if (isSame) {
    p += temp;
  }
  score += p;
  return score;
}

function getBoard(퍼즐판, 조작) {
  let s = 0;
  for (let i = 0; i < 퍼즐판.length; i++) {
    if (퍼즐판[i][조작 - 1] !== 0) {
      stack.push(퍼즐판[i][조작 - 1]);
      퍼즐판[i][조작 - 1] = 0;
      return s; // 0이 아닌 숫자를 만나면 함수 종료
    }
  }
  // 다 돌았다는 이야기는 0 밖에 없었다.
  // 그래서 score를 -1 해야한다.

  return s - 1;
}
console.log(solution(퍼즐판, 조작));
// 다시 for문 돌아 ( 또는 shift하고 while문으로 조작.length >0 동안 실행)

// 1. 이 문제를 보고 어떻게 이 솔루션을 떠올렸지?
// 조작의 숫자는 퍼즐판의 다른 줄의 같은 번째를 의미한다. (퍼즐판[줄][조작-1])
// 그 번째중 0이 아닌 숫자가 있으면 그 숫자를 stack에 추가
// 그 번째중에 0이 아닌 숫자가 없으면 -1
// 생각을 해보니 조작을 하나씩 없애면서 stack만 먼저 만들고
// stack 계산을 하면 되잖아?

// for문을 돌다가 0 아닌 숫자를 만나면 stack에 추가를 하고 멈추고 점수는 0
// for문을 다 돌았다 (즉, 0만 있다) 그럼 점수 -1
// 이 점수들을 합산하면 조작에 의해서 마이너스를 먼저 구할 수 있다.
// 조작를 하나씩 없애니까 길이가 0이 아닌 동안 for문을 반복 (getBoard() 함수)

// stack 점수를 구하는데 오래걸렸다.
// 풀이에서는 3연속에 대해서는 대응을 하지 않았다. 그냥 *2 해버림
// 이전숫자와 일시적 합산(3연속대비)와 전체합산을 만들었다.
// - 이전숫자, 일시적 합산에는 1번째 값을 넣음
// - for문은 인덱스 1부터
// - 아니라면 인덱스 0은 대입하는 if문 만들면 됨

// 이전숫자와 같으면 일시적 합산에 두 숫자를 더한다.
// 이전숫자는 현재숫자로 업데이트
// 만약 다르다면 일시적 합산 값을 전체합산에 더하고
// 이전숫자는 현재 숫자로 업데이트

// 여기서 문제발생
// 1,2번째가 같고 3번째가 다르고 4번째가 다르면 3번째의 일시적 합산 값을 바로 더해버림
// 그래서 isSame 구분자 값을 생성
// - 처음에 false로 시작
// 같으면 true, 다르면 false
// 하지만 이전숫자와 다를 때 구분값을 보고 일시적 합산 값을 전체합산에 더함
// - 이전숫자와 다르고 구분값이 true이면 2,2,5 상황
// - 이전숫자와 다르고 구분값이 false이면 5,4 상황
