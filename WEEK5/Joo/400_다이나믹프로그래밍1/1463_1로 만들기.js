// https://www.acmicpc.net/problem/1463

const fs = require("fs");
const input =
  process.platform === "linux"
    ? fs.readFileSync("/dev/stdin").toString().trim()
    : `10`;

const n = Number(input);
const dp = new Array(n + 1).fill(0);

// dp[i] => i가 되는데 필요한 연산의 최소값

for (let i = 2; i <= n; i++) {
  dp[i] = dp[i - 1] + 1; // 기존숫자에서 -1만하는 횟수
  if (i % 2 === 0) {
    dp[i] = Math.min(dp[i / 2] + 1, dp[i]);
  }
  if (i % 3 === 0) {
    dp[i] = Math.min(dp[i / 3] + 1, dp[i]);
  }
}
console.log(dp[n]);

// dp에 계산값을 저장하는 것
// 0은 인덱스 맞추기 위해 존재
// 1은 바로 리턴하므로 최솟값이 0
// 그래서 2부터 시작

// 시작전에 dp[i] = dp[i - 1] + 1
// 기존 값의 횟수에 +1 하는게 스타트 , 비교점 만들기
//    - 2일 때 1의 횟수 +1하면 되고, 3일 때도 2의 횟수 +1하면 되고
//    - 4일 때 3의 횟수 +1을 하면 기본적인 횟수가 나온다.

// 2는 dp[2/2] + 1 => 횟수 1 와 dp[2] => 횟수 1 중 최소값 선택
//    - dp[2/2] + 1 ?
//    - 나누었을 때의 값이 1이고 , 우리는 1의 횟수를 알고 있다. 횟수 0
//    - 그래서 2를 2로 나누는 횟수 1을 증가시켜주는 거다.
//    - dp[2] ?
//    - 시작전에 dp[i] = dp[i - 1] + 1 을 해서 설정해 놓은
//    - 전 값에서 -1 하는 방식이다.

// 3는 dp[3/3] + 1 => 횟수 1 와 dp[3] => 횟수 2 중 최소값 선택
//    - dp[3/3] + 1 ?
//    - 나누었을 때의 값이 1이고 , 우리는 1의 횟수를 알고 있다. 횟수 0
//    - 그래서 3를 3로 나누는 횟수 1을 증가시켜주는 거다.

// 4는 dp[4/2] + 1 => 횟수 2 와 dp[4] => 횟수 2 중 최소값 선택
//    - dp[4/2] + 1 :
//    - 4를 2로 나누면 2 , 우리는 2의 횟수를 알고 있다.
//    - 그래서 4를 2로 나누는 횟수 1을 증가시켜주는 거다.

// 5는 dp[5] => 횟수 3
//    - 2 또는 3으로 나누어지지 않으므로
//    - 5에서 1를 빼서 4의 횟수를 더하는 방식으로 가야한다.
//    - 그래서 시작전에 dp[i] = dp[i - 1] + 1 통해서
//    - 전 값의 횟수(dp[4])에서 횟수가 1 증가한다.
//    - 시작전에 이미 했으므로 따로 if문을 만들지 않는다.

// 6는 dp[6/2] + 1 => 횟수 2 와 dp[6] => 횟수 4 중 최소값 선택
//    - 이제는 숙달되었겠지? 3의 횟수가 1 이고 6을 2로 나누는 횟수 1 증가
//    - 그래서 횟수 2
//    - dp[6] ?
//    - dp[5] + 1 => 횟수 3에 1증가

// 7는 dp[7] => 횟수 3
//    - 역시 2 또는 3으로 나누어 지지 않으니까
//    - 7에서 1을 빼서 6의 횟수에 더하는 방식

// 1 => 0
// 2 => 2,1 => 1
// 3 => 3,1 => 1
// 4 => 4,2,1 => 2
// 5 => 5,4,2,1  => 3
// 6 => 6,3,1 => 2
// 7 => 7,6,3,1 => 3
// 8 => 8,4,2,1 => 3
