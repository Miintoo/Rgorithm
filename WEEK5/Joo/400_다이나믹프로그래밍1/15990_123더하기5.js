// https://www.acmicpc.net/problem/15990

const fs = require("fs");
const input = (
  process.platform === "linux"
    ? fs.readFileSync("/dev/stdin").toString().trim()
    : `3
  4
  7
  100000`
)
  .split("\n")
  .map((v) => +v);
const t = input.shift();
const max = Math.max(...input);
const dp = new Array(100001).fill(new Array(4).fill(0));

dp[1] = [0, 1, 0, 0];
dp[2] = [0, 0, 1, 0];
dp[3] = [0, 1, 1, 1];

for (let j = 4; j <= max; j++) {
  const one = (dp[j - 1][2] + dp[j - 1][3]) % 1000000009;
  const two = (dp[j - 2][1] + dp[j - 2][3]) % 1000000009;
  const three = (dp[j - 3][1] + dp[j - 3][2]) % 1000000009;
  dp[j] = [0, one, two, three];
}

const result = [];

for (let i of input) {
  result.push((dp[i][1] + dp[i][2] + dp[i][3]) % 1000000009);
}
console.log(result.join("\n"));

// 1,2,3으로 끝나는 방법의 수를 각 정수 인덱스에 [0,1,2,3] 형식으로 저장
/* ** 처음 0은 인덱스를 맞추기 위한 무의미한 숫자
[
  [0,0,0,0]
  [0,1,0,0],
  [0,0,1,0],
  [0,1,1,1],
  ...
  ...
]
*/
// [[0,0,0,0],[0,0,0,0],...] 으로 기본값이 담긴 dp(저장배열)을 만든다.
// input(주어진 숫자 배열)을 돌면서 dp(저장배열)에 저장하는 형식으로 가면
// 5일 때도 5번을 만들고 9일때도 9번을 만드는 중복이 발생한다.
// 그래서 input 중 가장 큰 수를 구해서
// dp에 한번만 1,2,3으로 끝나는 방법의 수를 할당한다.
// 그리고 input을 돌면서 해당 dp[input값]의 합을 제시숫자로 나눈 나머지를 출력한다.

// 정수 n을 1,2,3의 합으로 나타내는 방법의 수?
// 고난1. 점화식 찾기
// 처음에 타일링 문제처럼 접근을 하였다.
// 만약 4일 때
// 숫자 1 + 3 만드는 방법 , 숫자 2 + 2 만드는 방법, 숫자 3 + 1 만드는 방법
// 숫자 1, 2, 3 로 시작하는 방법을 찾는 방식으로 갔다.

// 이런식으로 접근을 하니까 점화식 패턴이 보이지 않았다.
// 검색을 해보니까 앞이 아니라 숫자 1, 2, 3을 끝나는 방법을 찾는 방식으로 접근했다.
// 3 만드는 방법 + 숫자 1, 2 만드는 방법 + 숫자 2, 1 만드는 방법 + 숫자 3

// 3을 만드는 방법에 숫자 1을 붙여보면 패턴이 보인다.
/* 
n = 3일 때
end-1 = 2,1
end-2 = 1,2
end-3 = 3

n = 4 일 때 
end-1 = 1,2,1 / 3,1
end-2 = X
end-3 = 1,3
*/
// 약간의 패턴이 보이는 것이 3을 만드는 방법에 1을 붙이면
// 3의 end-1을 사용할 수 없다. (반복불가)
// 그리고 3의 end-2, end-3을 에 1만 붙이면 된다.
// 그렇다면 4의 end-1은
// 3의 방법의 수 -1 이 아니라
// 3의 end-1을 제외한 end-2 + end-3 이 된다.

// 그럼 4의 end-2는? 왜 없을까?
// 2를 만드는 방법은 1,1(중복) / 2 이다.
// 뒤에 2를 붙이면 2,2(중복)이 되어서 없는 것이다.
// 2를 만드는 방법을 1,2,3으로 끝나는 방식으로 표현하면
// end-1 => X , end-2 => 2, end-3 => X

// 4의 end-2는
// 2의 end-2를 제외한 end-2 + end-3 이라서 0이 된다.

// 4의 end-3은?
// 1을 만드는 방법은 end-1 => 1 , end-2 => X, end-3 => X
// 1의 end-3을 제외한 end-1 + end-2 이 된다.

// 1,2,3으로 끝난다는 앞에서 n-1, n-2, n-3을 만들어라는 것이다.
// 각각 n-1, n-2, n-3의 해당 end-1, end-2, end-3을 제외한 나머지 방법의 수를 더하면 된다.

/* ** 처음 0은 자리수를 맞추기 위한 무의미한 숫자
[
  [0,0,0,0]
  [0,1,0,0],
  [0,0,1,0],
  [0,1,1,1],
  [0,2,0,1],
  ...
  ...
]
- 1로 끝나? 
dp[n-1]의 1로 끝나는 경우의 수를 제외한 2,3으로 끝나는 경우의 수를 더해
그게 n의 1로 끝나는 경우의 수
- 2로 끝나? 
dp[n-2]의 2로 끝나는 경우의 수를 제외한 1,3으로 끝나는 경우의 수를 더해
그게 n의 2로 끝나는 경우의 수
- 3로 끝나? 
dp[n-3]의 3로 끝나는 경우의 수를 제외한 1,3으로 끝나는 경우의 수를 더해
그게 n의 3로 끝나는 경우의 수
*/
// dp[0], dp[n][0]을 제외한 (인덱스를 편하게 쓰기 위한) 해당인덱스에 맞게 할당해주면 된다.
// 그러면 끝날 줄 알았는데....!
// n의 최대값 100,000을 대입하면 NaN 즉, 숫자가 너무 커서 Number에 담을 수 없는 에러가 나온다.
// 그래서 다시 검색을 해보니까
// dp에 할당할 때 1,000,000,009로 나눈 나머지를 대입한다.
// 어...? 그럼 값이 달라지지 않는가?
// 우리가 몫이 필요한 것이 아니라 나머지가 필요한 것이라서
// n이 작을 때 부터 입력이 되어 있다면 NaN 이슈는 해결할 수 있다.
// 1 % 10000 과 10001 % 10000의 값은 같다.
